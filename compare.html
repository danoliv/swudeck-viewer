<!DOCTYPE html>
<html>
<head>
    <title>SWU Deck Comparison</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        /* Page-specific styles only */
        .comparison-results {
            margin-top: 20px;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <div class="navigation">
        <a href="index.html">&lt; Back to Deck Viewer</a>
        <a href="compare.html">Deck Comparison</a>
    </div>
    
    <h1>SWU Deck Comparison</h1>
    
    <div class="deck-inputs">
        <div class="deck-input-group">
            <h3>Deck 1</h3>
            <input type="text" id="deck1Url" placeholder="Paste SWUDB deck URL...">
            <button onclick="loadDeck(1)">Load Deck 1</button>
            <span id="loading1" class="loading" style="display: none;">Loading...</span>
            <div id="error1" class="error"></div>
            <div id="deck1Info" class="deck-info" style="display: none;"></div>
        </div>
        
        <div class="reverse-button-container" style="display: flex; align-items: center; justify-content: center;">
            <button onclick="reverseDeckOrder()" style="background: #ff9800; color: white; border: none; padding: 12px 20px; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 14px; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">
                Reverse Order
            </button>
        </div>
        
        <div class="deck-input-group">
            <h3>Deck 2</h3>
            <input type="text" id="deck2Url" placeholder="Paste SWUDB deck URL...">
            <button onclick="loadDeck(2)">Load Deck 2</button>
            <span id="loading2" class="loading" style="display: none;">Loading...</span>
            <div id="error2" class="error"></div>
            <div id="deck2Info" class="deck-info" style="display: none;"></div>
        </div>
    </div>
    
    <div id="comparisonResults" class="comparison-results" style="display: none;"></div>

<script src="card-module.js"></script>
<script>
    // External proxy used for static deployments
    const PROXY = 'https://api.allorigins.win/raw?url=';
    const TIMEOUT_MS = 10000; // 10 second timeout

    // Helper to fetch via the external proxy (no direct fetch attempt)
    async function fetchUsingExternalProxy(targetUrl, retries = 3, bypassCache = false) {
        const build = (u) => `${PROXY}${encodeURIComponent(u)}`;
        let lastError = null;
        for (let attempt = 0; attempt < retries; attempt++) {
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), TIMEOUT_MS);
                const urlWithBypass = bypassCache ? `${targetUrl}${targetUrl.includes('?') ? '&' : '?'}_t=${Date.now()}` : targetUrl;
                const response = await fetch(build(urlWithBypass), { signal: controller.signal, cache: 'no-cache' });
                clearTimeout(timeoutId);
                if (!response.ok) throw new Error(`Proxy HTTP ${response.status}`);
                const contentType = response.headers.get('content-type') || '';
                if (contentType.includes('application/json')) return await response.json();
                const text = await response.text();
                try { return JSON.parse(text); } catch (e) { return text; }
            } catch (err) {
                lastError = err;
                console.warn('fetchUsingExternalProxy attempt failed:', err && err.message ? err.message : err);
                await new Promise(r => setTimeout(r, 500 * (attempt + 1)));
            }
        }
        throw new Error(`Proxy fetch failed: ${lastError ? lastError.message : 'unknown'}`);
    }

    // Store loaded deck data
    let deck1Data = null;
    let deck2Data = null;

    // Utility function to retry failed fetch requests with proxy fallbacks
    async function fetchWithRetry(url, retries = 3, bypassCache = false) {
        // Try direct first (null), then fallbacks
        const proxies = [
            'https://api.allorigins.win/get?url=',
            'https://thingproxy.freeboard.io/fetch/',
            'https://cors.bridged.cc/'
        ];

        const buildProxyUrl = (proxy, targetUrl) => {
            if (!proxy) return targetUrl;
            if (proxy.includes('allorigins')) return `${proxy}${encodeURIComponent(targetUrl)}`;
            if (proxy.endsWith('/fetch/') || proxy.endsWith('/')) return `${proxy}${targetUrl}`;
            return `${proxy}${encodeURIComponent(targetUrl)}`;
        };

        let lastError = null;
        for (const proxy of proxies) {
            for (let attempt = 0; attempt < retries; attempt++) {
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), TIMEOUT_MS);

                    const target = buildProxyUrl(proxy, bypassCache ? `${url}${url.includes('?') ? '&' : '?'}_t=${Date.now()}` : url);

                    const response = await fetch(target, {
                        signal: controller.signal,
                        cache: bypassCache ? 'no-cache' : 'default'
                    });
                    clearTimeout(timeoutId);

                    if (!response.ok) {
                        throw new Error(`HTTP error from ${proxy || 'direct'}: ${response.status}`);
                    }

                    // Handle AllOrigins.get wrapper: accept only if contents is valid JSON
                    if (proxy && proxy.includes('allorigins') && target.includes('/get?url=')) {
                        const wrapper = await response.json();
                        if (wrapper && wrapper.contents) {
                            const contents = String(wrapper.contents).trim();
                            try {
                                return JSON.parse(contents);
                            } catch (e) {
                                // Not valid JSON; treat as failure and try next proxy
                                throw new Error('AllOrigins returned non-JSON contents');
                            }
                        }
                        throw new Error('AllOrigins returned unexpected wrapper');
                    }

                    const contentType = response.headers.get('content-type');
                    if (contentType && contentType.includes('application/json')) {
                        return await response.json();
                    }

                    const text = await response.text();
                    try { return JSON.parse(text); } catch (e) { throw new Error('Response was not JSON'); }
                } catch (err) {
                    lastError = err;
                    if (err instanceof TypeError || /Failed to fetch|NetworkError|CORS|Access-Control-Allow-Origin/.test(String(err.message))) {
                        console.warn(`fetchWithRetry failed (proxy=${proxy || 'direct'}): likely CORS/network`, err.message || err);
                    } else {
                        console.warn(`fetchWithRetry failed (proxy=${proxy || 'direct'}):`, err.message || err);
                    }
                    if (attempt === retries - 1) break;
                    await new Promise(r => setTimeout(r, 500 * (attempt + 1)));
                }
            }
        }
        throw new Error(`All attempts failed: ${lastError ? lastError.message : 'unknown'}`);
    }

    async function loadDeck(deckNumber) {
        const urlInput = document.getElementById(`deck${deckNumber}Url`).value.trim();
        const errorDiv = document.getElementById(`error${deckNumber}`);
        const loading = document.getElementById(`loading${deckNumber}`);
        const deckInfo = document.getElementById(`deck${deckNumber}Info`);
        
        errorDiv.textContent = '';
        deckInfo.style.display = 'none';
        loading.style.display = 'inline';

        try {
            const url = new URL(urlInput);
            const pathSegments = url.pathname.split('/').filter(Boolean);
            const deckId = pathSegments[pathSegments.length - 1];
            
            if (!deckId) {
                throw new Error('Invalid SWUDB URL - Could not extract deck ID');
            }

            // Let code decide: prefer external proxy for static hosting by default,
            // but allow local/dev direct fetch via localStorage or localhost.
            const targetUrl = `https://swudb.com/api/getDeckJson/${deckId}`;
            const hostname = window.location && window.location.hostname ? window.location.hostname : '';
            const isLocalHost = hostname === 'localhost' || hostname === '127.0.0.1';
            const preferDirect = (typeof localStorage !== 'undefined' && localStorage.getItem('useDirectFetch') === 'true');
            let deckData;
            if (isLocalHost || preferDirect) {
                console.info('compare.html: using direct/dev fetch strategy (fetchWithRetry)');
                deckData = await fetchWithRetry(targetUrl, 3, true);
            } else {
                console.info('compare.html: using external proxy for fetch (production/static)');
                deckData = await fetchUsingExternalProxy(targetUrl, 3, true);
            }

            if (!deckData) {
                throw new Error('Failed to load deck data - Server returned empty response');
            }

            if (deckData.error) {
                throw new Error(`API Error: ${deckData.error}`);
            }

            if (!deckData.deck) {
                throw new Error('Invalid deck data format received from server');
            }

            // Store deck data
            if (deckNumber === 1) {
                deck1Data = deckData;
            } else {
                deck2Data = deckData;
            }

            // Display deck info
            const deckName = deckData.metadata?.name || 'Unnamed Deck';
            const deckSize = deckData.deck ? deckData.deck.length : 0;
            const sideboardSize = deckData.sideboard ? deckData.sideboard.length : 0;
            
            deckInfo.innerHTML = `
                <div class="deck-name">${deckName}</div>
                <div class="deck-stats">
                    Main Deck: ${deckSize} cards<br>
                    Sideboard: ${sideboardSize} cards
                </div>
            `;
            deckInfo.style.display = 'block';

            // Update URL with deck ID
            const currentUrl = new URL(window.location);
            if (deckNumber === 1) {
                currentUrl.searchParams.set('deck1', deckId);
            } else {
                currentUrl.searchParams.set('deck2', deckId);
            }
            window.history.pushState({}, '', currentUrl.toString());

            // Check if both decks are loaded and compare
            if (deck1Data && deck2Data) {
                await compareDecks();
            }

        } catch (err) {
            console.error(`Error loading deck ${deckNumber}:`, err);
            errorDiv.textContent = `Error: ${err.message}. Please verify the deck URL is correct and try again.`;
        } finally {
            loading.style.display = 'none';
        }
    }

    async function compareDecks() {
        if (!deck1Data || !deck2Data) return;

        const resultsDiv = document.getElementById('comparisonResults');
        resultsDiv.style.display = 'block';

        // Create card maps for both decks (main deck + sideboard)
        const deck1Cards = new Map();
        const deck2Cards = new Map();

        // Process deck 1 cards (main deck)
        if (deck1Data.deck) {
            deck1Data.deck.forEach(card => {
                if (card && card.id) {
                    const count = card.count || 1;
                    deck1Cards.set(card.id, { main: count, sideboard: 0 });
                }
            });
        }

        // Process deck 1 sideboard cards
        if (deck1Data.sideboard) {
            deck1Data.sideboard.forEach(card => {
                if (card && card.id) {
                    const count = card.count || 1;
                    if (deck1Cards.has(card.id)) {
                        deck1Cards.get(card.id).sideboard = count;
                    } else {
                        deck1Cards.set(card.id, { main: 0, sideboard: count });
                    }
                }
            });
        }

        // Process deck 2 cards (main deck)
        if (deck2Data.deck) {
            deck2Data.deck.forEach(card => {
                if (card && card.id) {
                    const count = card.count || 1;
                    deck2Cards.set(card.id, { main: count, sideboard: 0 });
                }
            });
        }

        // Process deck 2 sideboard cards
        if (deck2Data.sideboard) {
            deck2Data.sideboard.forEach(card => {
                if (card && card.id) {
                    const count = card.count || 1;
                    if (deck2Cards.has(card.id)) {
                        deck2Cards.get(card.id).sideboard = count;
                    } else {
                        deck2Cards.set(card.id, { main: 0, sideboard: count });
                    }
                }
            });
        }

        // Find differences
        const allCardIds = new Set([...deck1Cards.keys(), ...deck2Cards.keys()]);
        const deck1Only = [];
        const deck2Only = [];
        const differentCounts = [];
        const sameCards = [];

        for (const cardId of allCardIds) {
            const counts1 = deck1Cards.get(cardId) || { main: 0, sideboard: 0 };
            const counts2 = deck2Cards.get(cardId) || { main: 0, sideboard: 0 };
            
            const total1 = counts1.main + counts1.sideboard;
            const total2 = counts2.main + counts2.sideboard;

            if (total1 > 0 && total2 === 0) {
                deck1Only.push({ id: cardId, main: counts1.main, sideboard: counts1.sideboard });
            } else if (total1 === 0 && total2 > 0) {
                deck2Only.push({ id: cardId, main: counts2.main, sideboard: counts2.sideboard });
            } else if (counts1.main !== counts2.main || counts1.sideboard !== counts2.sideboard) {
                differentCounts.push({ 
                    id: cardId, 
                    deck1Main: counts1.main, 
                    deck1Sideboard: counts1.sideboard,
                    deck2Main: counts2.main, 
                    deck2Sideboard: counts2.sideboard 
                });
            } else if (total1 > 0 && total2 > 0) {
                sameCards.push({ id: cardId, main: counts1.main, sideboard: counts1.sideboard });
            }
        }

        // Get deck names
        const deck1Name = deck1Data.metadata?.name || 'Deck 1';
        const deck2Name = deck2Data.metadata?.name || 'Deck 2';
        
        // Generate comparison HTML
        let html = `<h2>Deck Comparison: ${deck1Name} vs ${deck2Name}</h2>`;
        
        // Summary stats
        html += `
            <div class="summary-stats">
                <div class="stat-card">
                    <div class="stat-number">${deck1Only.length}</div>
                    <div class="stat-label">Only in ${deck1Name}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${deck2Only.length}</div>
                    <div class="stat-label">Only in ${deck2Name}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${differentCounts.length}</div>
                    <div class="stat-label">Different Counts</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${sameCards.length}</div>
                    <div class="stat-label">Same Cards</div>
                </div>
            </div>
        `;

        // Cards only in deck 1
        if (deck1Only.length > 0) {
            html += `
                <div class="comparison-section">
                    <div class="comparison-header">Only in ${deck1Name} (${deck1Only.length} cards)</div>
                    <div class="comparison-content">
                        <div class="card-grid">
                            ${(await Promise.all(deck1Only.map(async card => {
                                const cardData = await fetchCardData(card.id);
                                return buildComparisonCardHTML(card.id, cardData, card.main, 0, 'deck1-only', deck1Name, deck2Name, card.sideboard, 0);
                            }))).join('')}
                        </div>
                    </div>
                </div>
            `;
        }

        // Cards only in deck 2
        if (deck2Only.length > 0) {
            html += `
                <div class="comparison-section">
                    <div class="comparison-header">Only in ${deck2Name} (${deck2Only.length} cards)</div>
                    <div class="comparison-content">
                        <div class="card-grid">
                            ${(await Promise.all(deck2Only.map(async card => {
                                const cardData = await fetchCardData(card.id);
                                return buildComparisonCardHTML(card.id, cardData, 0, card.main, 'deck2-only', deck1Name, deck2Name, 0, card.sideboard);
                            }))).join('')}
                        </div>
                    </div>
                </div>
            `;
        }

        // Cards with different counts
        if (differentCounts.length > 0) {
            html += `
                <div class="comparison-section">
                    <div class="comparison-header">Different Counts (${differentCounts.length} cards)</div>
                    <div class="comparison-content">
                        <div class="card-grid">
                            ${(await Promise.all(differentCounts.map(async card => {
                                const cardData = await fetchCardData(card.id);
                                return buildComparisonCardHTML(card.id, cardData, card.deck1Main, card.deck2Main, 'different-count', deck1Name, deck2Name, card.deck1Sideboard, card.deck2Sideboard);
                            }))).join('')}
                        </div>
                    </div>
                </div>
            `;
        }

        // Same cards
        if (sameCards.length > 0) {
            html += `
                <div class="comparison-section">
                    <div class="comparison-header">Same Cards (${sameCards.length} cards)</div>
                    <div class="comparison-content">
                        <div class="card-grid">
                            ${(await Promise.all(sameCards.map(async card => {
                                const cardData = await fetchCardData(card.id);
                                return buildComparisonCardHTML(card.id, cardData, card.main, card.main, 'same-card', deck1Name, deck2Name, card.sideboard, card.sideboard);
                            }))).join('')}
                        </div>
                    </div>
                </div>
            `;
        }

        resultsDiv.innerHTML = html;
    }

    // Reverse deck order function
    async function reverseDeckOrder() {
        if (!deck1Data || !deck2Data) {
            alert('Both decks must be loaded to reverse order');
            return;
        }

        // Swap the deck data
        const tempData = deck1Data;
        deck1Data = deck2Data;
        deck2Data = tempData;

        // Update the URL parameters
        const currentUrl = new URL(window.location);
        const deck1Id = deck1Data.metadata?.id || deck1Data.deck?.[0]?.id?.split('_')[0] || 'unknown';
        const deck2Id = deck2Data.metadata?.id || deck2Data.deck?.[0]?.id?.split('_')[0] || 'unknown';
        
        // Extract deck IDs from the current URLs
        const url1 = document.getElementById('deck1Url').value;
        const url2 = document.getElementById('deck2Url').value;
        const id1 = url1.split('/').pop();
        const id2 = url2.split('/').pop();
        
        currentUrl.searchParams.set('deck1', id2);
        currentUrl.searchParams.set('deck2', id1);
        window.history.pushState({}, '', currentUrl.toString());

        // Swap the input field values
        document.getElementById('deck1Url').value = url2;
        document.getElementById('deck2Url').value = url1;

        // Swap the deck info displays
        const deck1Info = document.getElementById('deck1Info');
        const deck2Info = document.getElementById('deck2Info');
        const tempInfo = deck1Info.innerHTML;
        deck1Info.innerHTML = deck2Info.innerHTML;
        deck2Info.innerHTML = tempInfo;

        // Regenerate the comparison
        await compareDecks();
    }

    // Check for deck IDs in URL when page loads
    window.addEventListener('load', async function() {
        const urlParams = new URLSearchParams(window.location.search);
        const deck1Id = urlParams.get('deck1');
        const deck2Id = urlParams.get('deck2');
        
        if (deck1Id) {
            document.getElementById('deck1Url').value = `https://swudb.com/deck/${deck1Id}`;
            await loadDeck(1);
        }
        if (deck2Id) {
            document.getElementById('deck2Url').value = `https://swudb.com/deck/${deck2Id}`;
            await loadDeck(2);
        }
    });
</script>
</body>
</html>
