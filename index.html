<!DOCTYPE html>
<html>
<head>
    <title>SWU Deck Viewer</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 1200px; margin: 20px auto; padding: 0 20px; }
        input { width: 500px; padding: 8px; margin-right: 10px; }
        button { padding: 8px 16px; background: #0066cc; color: white; border: none; cursor: pointer; }
        .set-group { margin: 30px 0; border: 1px solid #ddd; border-radius: 4px; }
        .set-header { background: #f5f5f5; padding: 10px; font-weight: bold; }
        .card-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 20px; padding: 15px; }
        .card { border: 1px solid #eee; border-radius: 4px; padding: 10px; background: white; }
        .card img { width: 100%; height: auto; border-radius: 3px; }
        .card-name { font-weight: bold; margin: 8px 0; }
        .card-id { 
            font-size: 1.2em; 
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
            padding: 5px;
            background: #f5f5f5;
            border-radius: 3px;
            text-align: center;
        }
        .loading { color: #666; margin-left: 10px; }
        .error { color: red; margin-top: 10px; }
        
        /* New styles */
        .leaders-section, .base-section { 
            background: #f8f8f8; 
            padding: 15px; 
            margin-bottom: 20px; 
            border-radius: 4px; 
        }
        .section-title {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 10px;
        }
        .card-stats {
            display: flex;
            gap: 10px;
            margin: 5px 0;
            font-size: 0.9em;
        }
        .stat {
            background: #eee;
            padding: 2px 6px;
            border-radius: 3px;
        }
        .aspects {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin: 5px 0;
        }
        .aspect {
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            color: white;
        }
        .aspect.Heroism { background: #FFFFFF; color: #000000; } /* White with black text */
        .aspect.Vigilance { background: #0066CC; } /* Blue */
        .aspect.Cunning { background: #FFD700; color: #000000; } /* Yellow with black text */
        .aspect.Command { background: #00A651; } /* Green */
        .aspect.Aggression { background: #FF0000; } /* Red */
        .aspect.Villainy { background: #000000; } /* Black */
        
        @media (max-width: 600px) {
            input { width: 100%; margin-bottom: 10px; }
            .card-grid { grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); }
        }

        /* Recent decks styles */
        .recent-decks {
            margin: 20px 0;
            padding: 15px;
            background: #f8f8f8;
            border-radius: 4px;
        }
        .recent-decks-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }
        .recent-decks-list {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            padding: 15px 0;
        }
        .recent-deck-btn {
            padding: 16px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 12px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 142px;  /* 110px + 16px padding on each side */
            position: relative;
            overflow: hidden;
        }
        .recent-deck-btn img {
            width: 110px;
            height: auto;
            border-radius: 12px;
            object-fit: cover;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 1;
        }
        .recent-deck-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            transition: all 0.2s ease;
        }
        .recent-deck-name {
            font-weight: bold;
            margin-bottom: 12px;
            z-index: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 2.4em;
            min-height: 2.4em;
            width: 100%;
            text-align: center;
            overflow: hidden;
        }
        .recent-deck-name span {
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.2;
        }
        .recent-deck-base-bg {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 0;
        }
    </style>
</head>
<body>
    <h1>SWU Deck Viewer</h1>
    <div>
        <input type="text" id="deckUrl" 
               placeholder="Paste SWUDB deck URL (e.g., https://swudb.com/deck/123...)">
        <button onclick="loadDeck()">Load Deck</button>
        <span id="loading" class="loading" style="display: none;">Loading...</span>
    </div>
    <div id="recentDecks" class="recent-decks"></div>
    <div id="error" class="error"></div>
    <div id="output"></div>
<script>
        // Use only AllOrigins as the CORS proxy
        const PROXY = 'https://api.allorigins.win/raw?url=';
        const TIMEOUT_MS = 10000; // 10 second timeout

        // Recent decks storage
        const MAX_RECENT_DECKS = 5;
        let recentDecks = JSON.parse(localStorage.getItem('recentDecks') || '[]');

        // Update recent decks UI
        function updateRecentDecksUI() {
            const recentDecksDiv = document.getElementById('recentDecks');
            if (recentDecks.length === 0) {
                recentDecksDiv.style.display = 'none';
                return;
            }

            let html = '<div class="recent-decks-title">Recent Decks:</div><div class="recent-decks-list">';
            recentDecks.forEach((deck, index) => {
                const leaderImg = deck.leaderArt ? 
                    `<img src="${deck.leaderArt}" alt="Leader" onerror="this.style.display='none'">` : '';
                
                html += `<button onclick="loadDeckFromUrl('${deck.url}')" class="recent-deck-btn">
                    <div class="aspect ${deck.baseAspect} recent-deck-base-bg"></div>
                    <div class="recent-deck-name"><span>${deck.name || 'Unnamed Deck'}</span></div>
                    ${leaderImg}
                </button>`;
            });
            html += '</div>';
            recentDecksDiv.innerHTML = html;
            recentDecksDiv.style.display = 'block';
        }

        // Add deck to recent list
        function addToRecentDecks(url, deckData) {
            const now = new Date();
            const dateStr = now.toLocaleDateString();
            
            // Get leader art URL and base aspect
            console.log('Deck data:', deckData);
            const leaderArt = deckData.leader?.FrontArt || (deckData.leader ? `https://cdn.swu-db.com/images/cards/${deckData.leader.id.replace('_', '/')}.png` : null);
            const baseAspect = deckData.base?.Aspects?.[0] || 'Command';
            
            console.log('Leader art:', leaderArt);
            console.log('Base aspect:', baseAspect);
            
            // Remove if already exists
            recentDecks = recentDecks.filter(deck => deck.url !== url);
            
            // Add to front of array
            recentDecks.unshift({ 
                url, 
                name: deckData.metadata?.name || 'Unnamed Deck',
                leaderArt,
                baseAspect,
                date: dateStr 
            });
            
            // Keep only last 5
            if (recentDecks.length > MAX_RECENT_DECKS) {
                recentDecks = recentDecks.slice(0, MAX_RECENT_DECKS);
            }
            
            // Save to localStorage
            localStorage.setItem('recentDecks', JSON.stringify(recentDecks));
            
            // Update UI
            updateRecentDecksUI();
        }

        // Load deck from URL
        async function loadDeckFromUrl(url) {
            document.getElementById('deckUrl').value = url;
            await loadDeck();
        }

        // Utility function to retry failed fetch requests
        async function fetchWithRetry(url, retries = 3) {
            for (let i = 0; i < retries; i++) {
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), TIMEOUT_MS);
                    
                    const response = await fetch(url, { signal: controller.signal });
                    clearTimeout(timeoutId);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const contentType = response.headers.get("content-type");
                    if (contentType && contentType.includes("application/json")) {
                        return await response.json();
                    } else {
                        throw new Error("Response was not JSON");
                    }
                } catch (error) {
                    if (i === retries - 1) throw error; // Last retry failed
                    console.warn(`Attempt ${i + 1} failed, retrying...`, error);
                    await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1))); // Exponential backoff
                }
            }
        }

        // Card data cache
        const cardSets = {};
        const loadingPromises = {};

        // Load card set data
        async function loadCardSet(set) {
            // Return cached data if available
            if (cardSets[set]) {
                return cardSets[set];
            }

            // Return existing promise if the set is already being loaded
            if (loadingPromises[set]) {
                return loadingPromises[set];
            }

            // Create new loading promise
            loadingPromises[set] = (async () => {
                try {
                    console.log(`Loading set ${set}...`);
                    const response = await fetch(`data/${set.toLowerCase()}.json`);
                    if (!response.ok) {
                        throw new Error(`Failed to load ${set} data: ${response.status}`);
                    }
                    const data = await response.json();
                    
                    // Check if data has the expected structure
                    const cards = data.data;
                    if (!Array.isArray(cards)) {
                        throw new Error(`Invalid data format for set ${set}: expected array in data property`);
                    }
                    
                    // Index cards by their number for faster lookup
                    cardSets[set] = {};
                    cards.forEach(card => {
                        if (card.Number) {
                            // Convert string numbers to integers if needed
                            const cardNumber = parseInt(card.Number, 10);
                            cardSets[set][cardNumber] = card;
                        }
                    });
                    
                    console.log(`Successfully loaded set ${set} with ${data.length} cards`);
                    return cardSets[set];
                } catch (error) {
                    console.error(`Error loading set ${set}:`, error);
                    delete cardSets[set]; // Remove failed cache entry
                    throw error;
                } finally {
                    delete loadingPromises[set]; // Clean up loading promise
                }
            })();

            return loadingPromises[set];
        }

        // Preload all sets
        async function preloadSets() {
            const sets = ['SOR', 'SHD', 'JTL', 'TWI'];
            try {
                await Promise.all(sets.map(set => loadCardSet(set)));
                console.log('All sets preloaded successfully');
            } catch (error) {
                console.error('Error preloading sets:', error);
            }
        }

        // Start preloading sets immediately
        preloadSets();

        async function fetchCardData(cardId) {
            const [set, num] = cardId.split('_');
            const number = parseInt(num, 10);
            
            try {
                const setData = await loadCardSet(set);
                if (!setData) {
                    throw new Error(`Set ${set} not found`);
                }

                const cardData = setData[number];
                if (!cardData) {
                    console.warn(`Card ${cardId} not found in set ${set}`);
                    return {
                        id: cardId,
                        Name: cardId,
                        Set: set,
                        Number: number
                    };
                }

                return cardData;
            } catch (error) {
                console.error(`Error fetching card ${cardId}:`, error);
                return {
                    id: cardId,
                    Name: cardId,
                    Set: set,
                    Number: number
                };
            }
        }

        // Update the loadDeck function
        async function loadDeck() {
            const urlInput = document.getElementById('deckUrl').value.trim();
            const output = document.getElementById('output');
            const errorDiv = document.getElementById('error');
            const loading = document.getElementById('loading');
            
            errorDiv.textContent = '';
            output.innerHTML = '';
            loading.style.display = 'inline';

            try {
                // Extract deck ID from URL
                const url = new URL(urlInput);
                const pathSegments = url.pathname.split('/').filter(Boolean);
                const deckId = pathSegments[pathSegments.length - 1];
                
                if (!deckId) {
                    throw new Error('Invalid SWUDB URL - Could not extract deck ID');
                }

                console.log('Loading deck:', deckId);
                
                // Use the CORS proxy for the API endpoint
                const deckData = await fetchWithRetry(`${PROXY}${encodeURIComponent(`https://swudb.com/api/getDeckJson/${deckId}`)}`);
                
                if (!deckData) {
                    throw new Error('Failed to load deck data - Server returned empty response');
                }

                if (deckData.error) {
                    throw new Error(`API Error: ${deckData.error}`);
                }

                // Validate deck data structure
                if (!deckData.deck) {
                    throw new Error('Invalid deck data format received from server');
                }

                // Add to recent decks
                addToRecentDecks(urlInput, deckData);

                // Process cards
                const grouped = groupCards(deckData.deck);
                await displayDeck(deckData, grouped);
            } catch (err) {
                console.error('Error loading deck:', err);
                errorDiv.textContent = `Error: ${err.message}. Please verify the deck URL is correct and try again.`;
            } finally {
                loading.style.display = 'none';
            }
        }

        function groupCards(cards) {
            if (!Array.isArray(cards)) {
                console.error('Invalid cards data:', cards);
                return {};
            }

            const sets = {};
            cards.forEach(card => {
                if (!card || !card.id) {
                    console.warn('Invalid card data:', card);
                    return;
                }

                const [set, num] = card.id.split('_');
                if (!set || !num) {
                    console.warn('Invalid card ID format:', card.id);
                    return;
                }

                if (!sets[set]) sets[set] = [];
                sets[set].push({
                    id: card.id,
                    number: parseInt(num, 10),
                    count: card.count || 1
                });
            });
            
            // Sort cards within each set
            Object.keys(sets).forEach(set => {
                sets[set].sort((a, b) => a.number - b.number);
            });

            // Create a new object with sets in the desired order
            const orderedSets = {};
            const setOrder = ['SOR', 'SHD', 'TWI', 'JTL'];
            setOrder.forEach(set => {
                if (sets[set]) {
                    orderedSets[set] = sets[set];
                }
            });

            return orderedSets;
        }

        async function displayDeck(deckData, grouped) {
            const { metadata, leader, secondleader, base } = deckData;
            let html = `<h2>${metadata?.name || 'Unnamed Deck'}</h2>`;
            
            // Display leaders section
            if (leader || secondleader) {
                html += '<div class="leaders-section">';
                html += '<div class="section-title">Leaders</div>';
                html += '<div class="card-grid">';
                if (leader) {
                    const leaderCard = await fetchCardData(leader.id);
                    html += buildCardHTML(leader.id, leaderCard);
                }
                if (secondleader) {
                    const secondLeaderCard = await fetchCardData(secondleader.id);
                    html += buildCardHTML(secondleader.id, secondLeaderCard);
                }
                html += '</div></div>';
            }

            // Display base section
            if (base) {
                html += '<div class="base-section">';
                html += '<div class="section-title">Base</div>';
                html += '<div class="card-grid">';
                const baseCard = await fetchCardData(base.id);
                html += buildCardHTML(base.id, baseCard);
                html += '</div></div>';
            }

            // Process main deck sets
            for (const set of Object.keys(grouped)) {
                html += await buildSetHTML(set, grouped[set]);
            }

            output.innerHTML = html;
        }

        async function buildSetHTML(setCode, cardRefs) {
            // Fetch all cards in parallel
            const cardPromises = cardRefs.map(async ref => {
                const cardData = await fetchCardData(ref.id);
                return buildCardHTML(ref.id, cardData, ref.count);
            });

            const cardHtml = await Promise.all(cardPromises);

            return `
                <div class="set-group">
                    <div class="set-header">${setCode}</div>
                    <div class="card-grid">
                        ${cardHtml.join('')}
                    </div>
                </div>`;
        }

        function buildCardHTML(cardId, cardData = {}, count = 1) {
            const aspects = cardData.Aspects || [];
            const stats = [];
            if (cardData.Cost !== undefined) stats.push(['Cost', cardData.Cost]);
            if (cardData.Power !== undefined) stats.push(['Power', cardData.Power]);
            if (cardData.HP !== undefined) stats.push(['HP', cardData.HP]);

            return `
            <div class="card">
                <div class="card-id">${cardId.replace('_', ' ')}</div>
                ${cardData.FrontArt ? 
                    `<img src="${cardData.FrontArt}" alt="${cardData.Name || cardId}">` : 
                    `<div class="card-placeholder">${cardId}</div>`}
                <div class="card-name">${cardData.Name || cardId}${count > 1 ? ` (${count})` : ''}</div>
                ${aspects.length ? `
                    <div class="aspects">
                        ${aspects.map(aspect => `
                            <span class="aspect ${aspect}">${aspect}</span>
                        `).join('')}
                    </div>
                ` : ''}
                ${stats.length ? `
                    <div class="card-stats">
                        ${stats.map(([label, value]) => `
                            <span class="stat">${label}: ${value}</span>
                        `).join('')}
                    </div>
                ` : ''}
            </div>`;
        }

        // Initialize recent decks UI
        updateRecentDecksUI();
    </script>
</body>
</html>