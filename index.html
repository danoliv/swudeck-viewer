<!DOCTYPE html>
<html>
<head>
    <title>SWU Deck Viewer</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 1200px; margin: 20px auto; padding: 0 20px; }
        input { width: 500px; padding: 8px; margin-right: 10px; }
        button { padding: 8px 16px; background: #0066cc; color: white; border: none; cursor: pointer; }
        .set-group { margin: 30px 0; border: 1px solid #ddd; border-radius: 4px; }
        .set-header { background: #f5f5f5; padding: 10px; font-weight: bold; }
        .card-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 20px; padding: 15px; }
        .card { border: 1px solid #eee; border-radius: 4px; padding: 10px; background: white; }
        .card img { width: 100%; height: auto; border-radius: 3px; }
        .card-name { font-weight: bold; margin: 8px 0; }
        .card-id { color: #666; font-size: 0.9em; }
        .loading { color: #666; margin-left: 10px; }
        .error { color: red; margin-top: 10px; }
        
        /* New styles */
        .leaders-section, .base-section { 
            background: #f8f8f8; 
            padding: 15px; 
            margin-bottom: 20px; 
            border-radius: 4px; 
        }
        .section-title {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 10px;
        }
        .card-stats {
            display: flex;
            gap: 10px;
            margin: 5px 0;
            font-size: 0.9em;
        }
        .stat {
            background: #eee;
            padding: 2px 6px;
            border-radius: 3px;
        }
        .aspects {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin: 5px 0;
        }
        .aspect {
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            color: white;
        }
        .aspect.Heroism { background: #4a90e2; }
        .aspect.Vigilance { background: #7ed321; }
        .aspect.Cunning { background: #9013fe; }
        .aspect.Command { background: #f5a623; }
        .aspect.Aggression { background: #d0021b; }
        .aspect.Villainy { background: #4a4a4a; }
        
        @media (max-width: 600px) {
            input { width: 100%; margin-bottom: 10px; }
            .card-grid { grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); }
        }
    </style>
</head>
<body>
    <h1>SWU Deck Viewer</h1>
    <div>
        <input type="text" id="deckUrl" 
               placeholder="Paste SWUDB deck URL (e.g., https://swudb.com/deck/123...)">
        <button onclick="loadDeck()">Load Deck</button>
        <span id="loading" class="loading" style="display: none;">Loading...</span>
    </div>
    <div id="error" class="error"></div>
    <div id="output"></div>
<script>
        // Use only AllOrigins as the CORS proxy
        const PROXY = 'https://api.allorigins.win/raw?url=';
        const TIMEOUT_MS = 10000; // 10 second timeout

        // Utility function to retry failed fetch requests
        async function fetchWithRetry(url, retries = 3) {
            for (let i = 0; i < retries; i++) {
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), TIMEOUT_MS);
                    
                    const response = await fetch(url, { signal: controller.signal });
                    clearTimeout(timeoutId);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const contentType = response.headers.get("content-type");
                    if (contentType && contentType.includes("application/json")) {
                        return await response.json();
                    } else {
                        throw new Error("Response was not JSON");
                    }
                } catch (error) {
                    if (i === retries - 1) throw error; // Last retry failed
                    console.warn(`Attempt ${i + 1} failed, retrying...`, error);
                    await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1))); // Exponential backoff
                }
            }
        }

        // Card data cache
        const cardSets = {};
        const loadingPromises = {};

        // Load card set data
        async function loadCardSet(set) {
            // Return cached data if available
            if (cardSets[set]) {
                return cardSets[set];
            }

            // Return existing promise if the set is already being loaded
            if (loadingPromises[set]) {
                return loadingPromises[set];
            }

            // Create new loading promise
            loadingPromises[set] = (async () => {
                try {
                    console.log(`Loading set ${set}...`);
                    const response = await fetch(`data/${set.toLowerCase()}.json`);
                    if (!response.ok) {
                        throw new Error(`Failed to load ${set} data: ${response.status}`);
                    }
                    const data = await response.json();
                    
                    // Check if data has the expected structure
                    const cards = data.data;
                    if (!Array.isArray(cards)) {
                        throw new Error(`Invalid data format for set ${set}: expected array in data property`);
                    }
                    
                    // Index cards by their number for faster lookup
                    cardSets[set] = {};
                    cards.forEach(card => {
                        if (card.Number) {
                            // Convert string numbers to integers if needed
                            const cardNumber = parseInt(card.Number, 10);
                            cardSets[set][cardNumber] = card;
                        }
                    });
                    
                    console.log(`Successfully loaded set ${set} with ${data.length} cards`);
                    return cardSets[set];
                } catch (error) {
                    console.error(`Error loading set ${set}:`, error);
                    delete cardSets[set]; // Remove failed cache entry
                    throw error;
                } finally {
                    delete loadingPromises[set]; // Clean up loading promise
                }
            })();

            return loadingPromises[set];
        }

        // Preload all sets
        async function preloadSets() {
            const sets = ['SOR', 'SHD', 'JTL', 'TWI'];
            try {
                await Promise.all(sets.map(set => loadCardSet(set)));
                console.log('All sets preloaded successfully');
            } catch (error) {
                console.error('Error preloading sets:', error);
            }
        }

        // Start preloading sets immediately
        preloadSets();

        async function fetchCardData(cardId) {
            const [set, num] = cardId.split('_');
            const number = parseInt(num, 10);
            
            try {
                const setData = await loadCardSet(set);
                if (!setData) {
                    throw new Error(`Set ${set} not found`);
                }

                const cardData = setData[number];
                if (!cardData) {
                    console.warn(`Card ${cardId} not found in set ${set}`);
                    return {
                        id: cardId,
                        Name: cardId,
                        Set: set,
                        Number: number
                    };
                }

                return cardData;
            } catch (error) {
                console.error(`Error fetching card ${cardId}:`, error);
                return {
                    id: cardId,
                    Name: cardId,
                    Set: set,
                    Number: number
                };
            }
        }

        async function loadDeck() {
            const urlInput = document.getElementById('deckUrl').value.trim();
            const output = document.getElementById('output');
            const errorDiv = document.getElementById('error');
            const loading = document.getElementById('loading');
            
            errorDiv.textContent = '';
            output.innerHTML = '';
            loading.style.display = 'inline';

            try {
                // Extract deck ID from URL
                const url = new URL(urlInput);
                const pathSegments = url.pathname.split('/').filter(Boolean);
                const deckId = pathSegments[pathSegments.length - 1];
                
                if (!deckId) {
                    throw new Error('Invalid SWUDB URL - Could not extract deck ID');
                }

                console.log('Loading deck:', deckId);
                
                // Use the CORS proxy for the API endpoint
                const deckData = await fetchWithRetry(`${PROXY}${encodeURIComponent(`https://swudb.com/api/getDeckJson/${deckId}`)}`);
                
                if (!deckData) {
                    throw new Error('Failed to load deck data - Server returned empty response');
                }

                if (deckData.error) {
                    throw new Error(`API Error: ${deckData.error}`);
                }

                // Validate deck data structure
                if (!deckData.deck) {
                    throw new Error('Invalid deck data format received from server');
                }

                // Process cards
                const grouped = groupCards(deckData.deck);
                await displayDeck(deckData, grouped);
            } catch (err) {
                console.error('Error loading deck:', err);
                errorDiv.textContent = `Error: ${err.message}. Please verify the deck URL is correct and try again.`;
            } finally {
                loading.style.display = 'none';
            }
        }

        function groupCards(cards) {
            if (!Array.isArray(cards)) {
                console.error('Invalid cards data:', cards);
                return {};
            }

            const sets = {};
            cards.forEach(card => {
                if (!card || !card.id) {
                    console.warn('Invalid card data:', card);
                    return;
                }

                const [set, num] = card.id.split('_');
                if (!set || !num) {
                    console.warn('Invalid card ID format:', card.id);
                    return;
                }

                if (!sets[set]) sets[set] = [];
                sets[set].push({
                    id: card.id,
                    number: parseInt(num, 10),
                    count: card.count || 1
                });
            });
            
            // Sort sets and cards
            return Object.keys(sets).sort().reduce((acc, set) => {
                acc[set] = sets[set].sort((a, b) => a.number - b.number);
                return acc;
            }, {});
        }

        async function displayDeck(deckData, grouped) {
            const { metadata, leader, secondleader, base } = deckData;
            let html = `<h2>${metadata?.name || 'Unnamed Deck'}</h2>`;
            
            // Display leaders section
            if (leader || secondleader) {
                html += '<div class="leaders-section">';
                html += '<div class="section-title">Leaders</div>';
                html += '<div class="card-grid">';
                if (leader) {
                    const leaderCard = await fetchCardData(leader.id);
                    html += buildCardHTML(leader.id, leaderCard);
                }
                if (secondleader) {
                    const secondLeaderCard = await fetchCardData(secondleader.id);
                    html += buildCardHTML(secondleader.id, secondLeaderCard);
                }
                html += '</div></div>';
            }

            // Display base section
            if (base) {
                html += '<div class="base-section">';
                html += '<div class="section-title">Base</div>';
                html += '<div class="card-grid">';
                const baseCard = await fetchCardData(base.id);
                html += buildCardHTML(base.id, baseCard);
                html += '</div></div>';
            }

            // Process main deck sets
            for (const set of Object.keys(grouped)) {
                html += await buildSetHTML(set, grouped[set]);
            }

            output.innerHTML = html;
        }

        async function buildSetHTML(setCode, cardRefs) {
            // Fetch all cards in parallel
            const cardPromises = cardRefs.map(async ref => {
                const cardData = await fetchCardData(ref.id);
                return buildCardHTML(ref.id, cardData, ref.count);
            });

            const cardHtml = await Promise.all(cardPromises);

            return `
                <div class="set-group">
                    <div class="set-header">${setCode}</div>
                    <div class="card-grid">
                        ${cardHtml.join('')}
                    </div>
                </div>`;
        }

        function buildCardHTML(cardId, cardData = {}, count = 1) {
            const aspects = cardData.Aspects || [];
            const stats = [];
            if (cardData.Cost !== undefined) stats.push(['Cost', cardData.Cost]);
            if (cardData.Power !== undefined) stats.push(['Power', cardData.Power]);
            if (cardData.HP !== undefined) stats.push(['HP', cardData.HP]);

            return `
            <div class="card">
                ${cardData.FrontArt ? 
                    `<img src="${cardData.FrontArt}" alt="${cardData.Name || cardId}">` : 
                    `<div class="card-placeholder">${cardId}</div>`}
                <div class="card-name">${cardData.Name || cardId}${count > 1 ? ` (${count})` : ''}</div>
                ${aspects.length ? `
                    <div class="aspects">
                        ${aspects.map(aspect => `
                            <span class="aspect ${aspect}">${aspect}</span>
                        `).join('')}
                    </div>
                ` : ''}
                ${stats.length ? `
                    <div class="card-stats">
                        ${stats.map(([label, value]) => `
                            <span class="stat">${label}: ${value}</span>
                        `).join('')}
                    </div>
                ` : ''}
                <div class="card-id">${cardId}</div>
            </div>`;
        }
    </script>
</body>
</html>