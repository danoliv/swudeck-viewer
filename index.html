<!DOCTYPE html>
<html>
<head>
    <title>SWU Deck Viewer</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 1200px; margin: 20px auto; padding: 0 20px; }
        input { width: 500px; padding: 8px; margin-right: 10px; }
        button { padding: 8px 16px; background: #0066cc; color: white; border: none; cursor: pointer; }
        .set-group { margin: 30px 0; border: 1px solid #ddd; border-radius: 4px; }
        .set-header { background: #f5f5f5; padding: 10px; font-weight: bold; }
        .card-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; padding: 15px; }
        @media (max-width: 1000px) { .card-grid { grid-template-columns: repeat(3, 1fr); } }
        @media (max-width: 800px) { .card-grid { grid-template-columns: repeat(2, 1fr); } }
        @media (max-width: 500px) { .card-grid { grid-template-columns: 1fr; } }
        .card { 
            border: 1px solid #eee; 
            border-radius: 4px; 
            padding: 10px; 
            background: white;
            position: relative;
            cursor: pointer;
            transition: filter 0.2s ease, transform 0.2s ease;
            text-align: center;
        }
        .card-images {
            position: relative;
            width: 100%;
            margin: 5px 0;
            perspective: 1000px;
            height: 0;
            padding-bottom: 140%;
        }
        .card-images-inner {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }
        .card.flipped .card-images-inner {
            transform: rotateY(180deg);
        }
        .card-front, .card-back {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f5f5f5;
        }
        .card-front img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 3px;
        }
        .card-back img {
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            object-fit: contain;
            border-radius: 3px;
        }
        .card-back {
            transform: rotateY(180deg);
        }
        .flip-button {
            position: static;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.75em;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            margin-left: auto;
        }
        .flip-button:hover {
            background: rgba(0, 0, 0, 0.95);
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
        }
        .card-content {
            position: relative;
            z-index: 2;
            background: white;
        }
        .card.selected {
            filter: grayscale(100%) brightness(95%);
            transform: scale(0.98);
            opacity: 0.7;
        }
        .card-id { 
            font-size: 1.2em; 
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
            padding: 5px;
            background: #f5f5f5;
            border-radius: 3px;
            text-align: center;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
        }
        .card-name {
            font-weight: bold;
            margin: 8px 0;
            text-align: center;
        }
        .loading { color: #666; margin-left: 10px; }
        .error { color: red; margin-top: 10px; }
        
        /* New styles */
        .leaders-section, .base-section { 
            background: #f8f8f8; 
            padding: 15px; 
            margin-bottom: 20px; 
            border-radius: 4px;
            display: inline-block;
            vertical-align: top;
        }
        .deck-header {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            padding: 10px;
            background: #f8f8f8;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        .deck-header .section-title {
            grid-column: 1 / -1;
        }
        .section-title {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 10px;
        }
        .card-stats {
            display: flex;
            gap: 10px;
            margin: 5px 0;
            justify-content: center;
            flex-wrap: wrap;
        }
        .stat {
            background: #eee;
            padding: 2px 8px;
            border-radius: 3px;
            color: white;
            font-size: 1.1em;
        }
        .stat[data-type="Cost"] {
            background: #FFB300; /* Yellow for cost */
        }
        .stat[data-type="Power"] {
            background: #D32F2F; /* Red for power */
        }
        .stat[data-type="HP"] {
            background: #1976D2; /* Blue for HP */
        }
        .stat-value {
            font-weight: bold;
            margin-left: 2px;
        }
        .aspects {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin: 5px 0;
            justify-content: center;
        }
        .aspect {
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            color: white;
        }
        .aspect.Heroism { background: #FFFFFF; color: #000000; border: 1px solid #000000; } /* White with black text and border */
        .aspect.Vigilance { background: #0066CC; } /* Official SWU Blue */
        .aspect.Cunning { background: #FFD700; color: #000000; } /* Official SWU Yellow */
        .aspect.Command { background: #00A651; } /* Official SWU Green */
        .aspect.Aggression { background: #FF0000; } /* Official SWU Red */
        .aspect.Villainy { background: #000000; } /* Official SWU Black */
        
        @media (max-width: 600px) {
            input { width: 100%; margin-bottom: 10px; }
            .card-grid { grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); }
        }

        /* Recent decks styles */
        .recent-decks {
            margin: 20px 0;
            padding: 15px;
            background: #f8f8f8;
            border-radius: 4px;
        }
        .recent-decks-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }
        .recent-decks-list {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            padding: 15px 0;
        }
        .recent-deck-btn {
            padding: 16px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 12px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 142px;  /* 110px + 16px padding on each side */
            position: relative;
            overflow: hidden;
        }
        .recent-deck-btn img {
            width: 110px;
            height: auto;
            border-radius: 12px;
            object-fit: cover;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 1;
        }
        .recent-deck-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            transition: all 0.2s ease;
        }
        .recent-deck-name {
            font-weight: bold;
            margin-bottom: 12px;
            z-index: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 2.4em;
            min-height: 2.4em;
            width: 100%;
            text-align: center;
            overflow: hidden;
        }
        .recent-deck-name span {
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.2;
        }
        .recent-deck-base-bg {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 0;
        }
        .sort-controls {
            margin: 20px 0;
            padding: 15px;
            background: #f8f8f8;
            border-radius: 4px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }
        .sort-button {
            padding: 8px 16px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
            color: #333;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
        }
        .sort-button:hover {
            background: #f0f0f0;
            transform: translateY(-1px);
            border-color: #0066cc;
            color: #0066cc;
        }
        .sort-button.active {
            background: #0066cc;
            color: white;
            border-color: #0066cc;
            box-shadow: 0 2px 4px rgba(0, 102, 204, 0.2);
        }
        .sort-label {
            font-weight: bold;
            margin-right: 10px;
        }
        /* Make leader and base cards bigger */
        .deck-header .card {
            max-width: 800px; /* Much larger max width */
            margin: 0 auto;
            width: 100%;
        }
        .deck-header .card-images {
            padding-bottom: 140%; /* Same aspect ratio as other cards */
            margin: 5px 0; /* Reduced vertical margin */
        }
        @media (max-width: 2000px) {
            .deck-header .card {
                max-width: 600px;
            }
        }
        @media (max-width: 1600px) {
            .deck-header .card {
                max-width: 500px;
            }
        }
    </style>
</head>
<body>
    <h1>SWU Deck Viewer</h1>
    <div>
        <input type="text" id="deckUrl" 
               placeholder="Paste SWUDB deck URL (e.g., https://swudb.com/deck/123...)">
        <button onclick="loadDeck()">Load Deck</button>
        <span id="loading" class="loading" style="display: none;">Loading...</span>
    </div>
    <div id="recentDecks" class="recent-decks"></div>
    <div id="error" class="error"></div>
    <div id="output"></div>
<script>
        // Use only AllOrigins as the CORS proxy
        const PROXY = 'https://api.allorigins.win/raw?url=';
        const TIMEOUT_MS = 10000; // 10 second timeout

        // Recent decks storage
        const MAX_RECENT_DECKS = 8;
        let recentDecks = JSON.parse(localStorage.getItem('recentDecks') || '[]');

        // Update recent decks UI
        function updateRecentDecksUI() {
            const recentDecksDiv = document.getElementById('recentDecks');
            if (recentDecks.length === 0) {
                recentDecksDiv.style.display = 'none';
                return;
            }

            let html = '<div class="recent-decks-title">Recent Decks:</div><div class="recent-decks-list">';
            recentDecks.forEach((deck, index) => {
                const leaderImg = deck.leaderArt ? 
                    `<img src="${deck.leaderArt}" alt="Leader" onerror="this.style.display='none'">` : '';
                
                html += `<button onclick="loadDeckFromUrl('${deck.url}')" class="recent-deck-btn">
                    <div class="aspect ${deck.baseAspect} recent-deck-base-bg"></div>
                    <div class="recent-deck-name"><span>${deck.name || 'Unnamed Deck'}</span></div>
                    ${leaderImg}
                </button>`;
            });
            html += '</div>';
            recentDecksDiv.innerHTML = html;
            recentDecksDiv.style.display = 'block';
        }

        // Add deck to recent list
        async function addToRecentDecks(url, deckData) {
            const now = new Date();
            const dateStr = now.toLocaleDateString();
            
            // Get leader art URL and base aspect
            console.log('Deck data:', deckData);
            const leaderArt = deckData.leader?.FrontArt || (deckData.leader ? `https://cdn.swu-db.com/images/cards/${deckData.leader.id.replace('_', '/')}.png` : null);
            
            // Fetch base card data to get correct aspect
            let baseAspect = 'Command'; // Default
            if (deckData.base?.id) {
                const baseCardData = await fetchCardData(deckData.base.id);
                if (baseCardData?.Aspects?.length > 0) {
                    baseAspect = baseCardData.Aspects[0];
                }
            }
            
            console.log('Leader art:', leaderArt);
            console.log('Base aspect:', baseAspect);
            
            // Remove if already exists
            recentDecks = recentDecks.filter(deck => deck.url !== url);
            
            // Add to front of array
            recentDecks.unshift({ 
                url, 
                name: deckData.metadata?.name || 'Unnamed Deck',
                leaderArt,
                baseAspect,
                date: dateStr 
            });
            
            // Keep only last 8 recent decks
            if (recentDecks.length > MAX_RECENT_DECKS) {
                recentDecks = recentDecks.slice(0, MAX_RECENT_DECKS);
            }
            
            // Save to localStorage
            localStorage.setItem('recentDecks', JSON.stringify(recentDecks));
            
            // Update UI
            updateRecentDecksUI();
        }

        // Load deck from URL
        async function loadDeckFromUrl(url) {
            document.getElementById('deckUrl').value = url;
            await loadDeck();
        }

        // Utility function to retry failed fetch requests
        async function fetchWithRetry(url, retries = 3) {
            for (let i = 0; i < retries; i++) {
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), TIMEOUT_MS);
                    
                    const response = await fetch(url, { signal: controller.signal });
                    clearTimeout(timeoutId);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const contentType = response.headers.get("content-type");
                    if (contentType && contentType.includes("application/json")) {
                        return await response.json();
                    } else {
                        throw new Error("Response was not JSON");
                    }
                } catch (error) {
                    if (i === retries - 1) throw error; // Last retry failed
                    console.warn(`Attempt ${i + 1} failed, retrying...`, error);
                    await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1))); // Exponential backoff
                }
            }
        }

        // Card data cache
        const cardSets = {};
        const loadingPromises = {};

        // Load card set data
        async function loadCardSet(set) {
            // Return cached data if available
            if (cardSets[set]) {
                return cardSets[set];
            }

            // Return existing promise if the set is already being loaded
            if (loadingPromises[set]) {
                return loadingPromises[set];
            }

            // Create new loading promise
            loadingPromises[set] = (async () => {
                try {
                    console.log(`Loading set ${set}...`);
                    const response = await fetch(`data/${set.toLowerCase()}.json`);
                    if (!response.ok) {
                        throw new Error(`Failed to load ${set} data: ${response.status}`);
                    }
                    const data = await response.json();
                    
                    // Check if data has the expected structure
                    const cards = data.data;
                    if (!Array.isArray(cards)) {
                        throw new Error(`Invalid data format for set ${set}: expected array in data property`);
                    }
                    
                    console.log(`Successfully loaded set ${set} with ${cards.length} cards`);
                    
                    // Index cards by their number for faster lookup
                    cardSets[set] = {};
                    cards.forEach(card => {
                        if (card.Number) {
                            // Convert string numbers to integers if needed
                            const cardNumber = parseInt(card.Number, 10);
                            cardSets[set][cardNumber] = card;
                        }
                    });
                    
                    return cardSets[set];
                } catch (error) {
                    console.error(`Error loading set ${set}:`, error);
                    delete cardSets[set]; // Remove failed cache entry
                    throw error;
                } finally {
                    delete loadingPromises[set]; // Clean up loading promise
                }
            })();

            return loadingPromises[set];
        }

        // Preload all sets
        async function preloadSets() {
            const sets = ['SOR', 'SHD', 'JTL', 'TWI'];
            try {
                await Promise.all(sets.map(set => loadCardSet(set)));
                console.log('All sets preloaded successfully');
            } catch (error) {
                console.error('Error preloading sets:', error);
            }
        }

        // Start preloading sets immediately
        preloadSets();

        async function fetchCardData(cardId) {
            const [set, num] = cardId.split('_');
            const number = parseInt(num, 10);
            
            try {
                const setData = await loadCardSet(set);
                if (!setData) {
                    console.error(`Set ${set} not found`);
                    throw new Error(`Set ${set} not found`);
                }

                const cardData = setData[number];
                if (!cardData) {
                    console.warn(`Card ${cardId} not found in set ${set}`);
                    return {
                        id: cardId,
                        Name: cardId,
                        Set: set,
                        Number: number,
                        Type: 'Unknown'
                    };
                }

                // Add the card ID to the data
                cardData.id = cardId;
                
                // Ensure we have a Type field
                if (!cardData.Type) {
                    cardData.Type = 'Unknown';
                }

                return cardData;
            } catch (error) {
                console.error(`Error fetching card ${cardId}:`, error);
                return {
                    id: cardId,
                    Name: cardId,
                    Set: set,
                    Number: number,
                    Type: 'Unknown'
                };
            }
        }

        // Check for deck ID in URL when page loads
        window.addEventListener('load', function() {
            // Check for deck in query parameters
            const urlParams = new URLSearchParams(window.location.search);
            const deckId = urlParams.get('deck');
            
            if (deckId) {
                loadDeckById(deckId);
            }
        });

        // Modify the loadDeck function
        async function loadDeck() {
            const urlInput = document.getElementById('deckUrl').value.trim();
            const output = document.getElementById('output');
            const errorDiv = document.getElementById('error');
            const loading = document.getElementById('loading');
            
            errorDiv.textContent = '';
            output.innerHTML = '';
            loading.style.display = 'inline';

            try {
                // Extract deck ID from URL
                const url = new URL(urlInput);
                const pathSegments = url.pathname.split('/').filter(Boolean);
                const deckId = pathSegments[pathSegments.length - 1];
                
                if (!deckId) {
                    throw new Error('Invalid SWUDB URL - Could not extract deck ID');
                }

                await loadDeckById(deckId);
                
                // Update URL without reloading the page
                window.history.pushState({}, '', `?deck=${deckId}`);

            } catch (err) {
                console.error('Error loading deck:', err);
                errorDiv.textContent = `Error: ${err.message}. Please verify the deck URL is correct and try again.`;
                loading.style.display = 'none';
            }
        }

        async function loadDeckById(deckId) {
            const errorDiv = document.getElementById('error');
            const output = document.getElementById('output');
            const loading = document.getElementById('loading');
            
            try {
                console.log('Loading deck:', deckId);
                
                // Use the CORS proxy for the API endpoint
                const deckData = await fetchWithRetry(`${PROXY}${encodeURIComponent(`https://swudb.com/api/getDeckJson/${deckId}`)}`);
                
                if (!deckData) {
                    throw new Error('Failed to load deck data - Server returned empty response');
                }

                if (deckData.error) {
                    throw new Error(`API Error: ${deckData.error}`);
                }

                // Validate deck data structure
                if (!deckData.deck) {
                    throw new Error('Invalid deck data format received from server');
                }

                // Add to recent decks
                await addToRecentDecks(`https://swudb.com/deck/${deckId}`, deckData);
                
                // Process cards
                const grouped = groupCards(deckData.deck);
                await displayDeck(deckData, grouped);
                
                // Update URL without reloading the page
                window.history.pushState({}, '', `?deck=${deckId}`);
                
            } catch (err) {
                console.error('Error loading deck:', err);
                errorDiv.textContent = `Error: ${err.message}. Please verify the deck ID is correct and try again.`;
            } finally {
                loading.style.display = 'none';
            }
        }

        function groupCards(cards) {
            if (!Array.isArray(cards)) {
                console.error('Invalid cards data:', cards);
                return {};
            }

            const sets = {};
            cards.forEach(card => {
                if (!card || !card.id) {
                    console.warn('Invalid card data:', card);
                    return;
                }

                const [set, num] = card.id.split('_');
                if (!set || !num) {
                    console.warn('Invalid card ID format:', card.id);
                    return;
                }

                if (!sets[set]) sets[set] = [];
                sets[set].push({
                    id: card.id,
                    number: parseInt(num, 10),
                    count: card.count || 1
                });
            });
            
            // Sort cards within each set
            Object.keys(sets).forEach(set => {
                sets[set].sort((a, b) => a.number - b.number);
            });

            // Create a new object with sets in the desired order
            const orderedSets = {};
            const setOrder = ['SOR', 'SHD', 'TWI', 'JTL'];
            setOrder.forEach(set => {
                if (sets[set]) {
                    orderedSets[set] = sets[set];
                }
            });

            return orderedSets;
        }

        async function displayDeck(deckData, grouped) {
            const { metadata, leader, secondleader, base } = deckData;
            const deckUrl = document.getElementById('deckUrl').value.trim();
            let html = `<h2><a href="${deckUrl}" target="_blank" style="color: inherit; text-decoration: none; border-bottom: 1px dotted #666;">${metadata?.name || 'Unnamed Deck'}</a></h2>`;

            // Add sorting controls
            html += `
            <div class="sort-controls">
                <span class="sort-label">Group by:</span>
                <button class="sort-button active" onclick="resortCards('set', this)">Set & Number</button>
                <button class="sort-button" onclick="resortCards('cost', this)">Cost</button>
                <button class="sort-button" onclick="resortCards('aspect', this)">Aspect</button>
                <button class="sort-button" onclick="resortCards('type', this)">Card Type</button>
                <button class="sort-button" onclick="resortCards('trait', this)">Traits</button>
            </div>`;
            
            // Display leaders and base in the same grid
            if (leader || secondleader || base) {
                html += '<div class="deck-header">';
                html += '<div class="section-title">Leaders & Base</div>';
                if (leader) {
                    const leaderCard = await fetchCardData(leader.id);
                    html += buildCardHTML(leader.id, leaderCard);
                }
                if (secondleader) {
                    const secondLeaderCard = await fetchCardData(secondleader.id);
                    html += buildCardHTML(secondleader.id, secondLeaderCard);
                }
                if (base) {
                    const baseCard = await fetchCardData(base.id);
                    html += buildCardHTML(base.id, baseCard);
                }
                html += '</div>';
            }

            // Store the grouped cards for resorting
            window.currentDeckCards = [];
            for (const set of Object.keys(grouped)) {
                for (const card of grouped[set]) {
                    const cardData = await fetchCardData(card.id);
                    window.currentDeckCards.push({
                        id: card.id,
                        count: card.count,
                        data: cardData
                    });
                }
            }

            // Initial sort by set
            html += await displaySortedCards('set');

            output.innerHTML = html;
        }

        async function displaySortedCards(sortType) {
            if (!window.currentDeckCards) return '';

            let sortedCards;
            switch (sortType) {
                case 'cost':
                    // Group by cost
                    const costGroups = {};
                    window.currentDeckCards.forEach(card => {
                        const cost = card.data.Cost !== undefined ? card.data.Cost : 'X';
                        if (!costGroups[cost]) costGroups[cost] = [];
                        costGroups[cost].push(card);
                    });
                    
                    let html = '';
                    Object.keys(costGroups).sort((a, b) => {
                        if (a === 'X') return 1;
                        if (b === 'X') return -1;
                        return parseInt(a) - parseInt(b);
                    }).forEach(cost => {
                        html += `
                            <div class="set-group">
                                <div class="set-header">Cost: ${cost}</div>
                                <div class="card-grid">
                                    ${costGroups[cost].map(card => 
                                        buildCardHTML(card.id, card.data, card.count)
                                    ).join('')}
                                </div>
                            </div>`;
                    });
                    return html;

                case 'aspect':
                    // Group by aspect
                    const aspectGroups = {};
                    window.currentDeckCards.forEach(card => {
                        const aspects = card.data.Aspects || ['None'];
                        aspects.forEach(aspect => {
                            if (!aspectGroups[aspect]) aspectGroups[aspect] = [];
                            aspectGroups[aspect].push(card);
                        });
                    });
                    
                    return Object.keys(aspectGroups).sort().map(aspect => `
                        <div class="set-group">
                            <div class="set-header">${aspect}</div>
                            <div class="card-grid">
                                ${aspectGroups[aspect].map(card => 
                                    buildCardHTML(card.id, card.data, card.count)
                                ).join('')}
                            </div>
                        </div>`
                    ).join('');

                case 'type':
                    // Group by card type with space/ground separation
                    const typeGroups = {};
                    window.currentDeckCards.forEach(card => {
                        let type = card.data.Type || 'Unknown';
                        console.log('Card:', card.data.Name, 'Type:', type, 'Arenas:', card.data.Arenas);
                        
                        // Split units into Space and Ground based on Arenas field
                        if (type === 'Unit') {
                            if (card.data.Arenas && card.data.Arenas.includes('Space')) {
                                type = 'Space Unit';
                            } else {
                                type = 'Ground Unit';
                            }
                        }
                        if (!typeGroups[type]) typeGroups[type] = [];
                        typeGroups[type].push(card);
                    });
                    
                    console.log('Final groups:', typeGroups);
                    
                    // Define type order with Ground Units first
                    const typeOrder = ['Ground Unit', 'Space Unit', 'Event', 'Upgrade', 'Unknown'];
                    return typeOrder
                        .filter(type => typeGroups[type] && typeGroups[type].length > 0)
                        .map(type => `
                            <div class="set-group">
                                <div class="set-header">${type} (${typeGroups[type].length})</div>
                                <div class="card-grid">
                                    ${typeGroups[type].map(card => 
                                        buildCardHTML(card.id, card.data, card.count)
                                    ).join('')}
                                </div>
                            </div>`
                        ).join('');

                case 'trait':
                    // Group by traits
                    const traitGroups = {};
                    window.currentDeckCards.forEach(card => {
                        console.log('Processing card:', card.data.Name);
                        console.log('Raw Traits:', card.data.Traits);
                        
                        // Handle traits that are already an array or convert string to array
                        const traits = Array.isArray(card.data.Traits) 
                            ? card.data.Traits 
                            : (card.data.Traits || '').split(',').map(t => t.trim());
                        
                        // Filter out empty traits
                        const validTraits = traits.filter(t => t);
                        
                        console.log('Processed Traits:', validTraits);
                        
                        if (validTraits.length === 0) {
                            // Handle cards with no traits
                            if (!traitGroups['No Traits']) traitGroups['No Traits'] = [];
                            traitGroups['No Traits'].push(card);
                            console.log('Added to No Traits group');
                        } else {
                            // Add card to each of its trait groups
                            validTraits.forEach(trait => {
                                if (!traitGroups[trait]) {
                                    traitGroups[trait] = [];
                                    console.log('Created new trait group:', trait);
                                }
                                traitGroups[trait].push(card);
                                console.log('Added to trait group:', trait);
                            });
                        }
                    });
                    
                    console.log('Final trait groups:', traitGroups);
                    
                    // Sort trait groups alphabetically, but put "No Traits" at the end
                    const sortedTraits = Object.keys(traitGroups)
                        .sort((a, b) => {
                            if (a === 'No Traits') return 1;
                            if (b === 'No Traits') return -1;
                            return a.localeCompare(b);
                        });

                    console.log('Sorted traits:', sortedTraits);

                    return sortedTraits
                        .map(trait => `
                            <div class="set-group">
                                <div class="set-header">${trait} (${traitGroups[trait].length})</div>
                                <div class="card-grid">
                                    ${traitGroups[trait].map(card => 
                                        buildCardHTML(card.id, card.data, card.count)
                                    ).join('')}
                                </div>
                            </div>`
                        ).join('');

                default: // 'set'
                    // Group by set
                    const setGroups = {};
                    window.currentDeckCards.forEach(card => {
                        const [set] = card.id.split('_');
                        if (!setGroups[set]) setGroups[set] = [];
                        setGroups[set].push(card);
                    });
                    
                    // Use the specified set order
                    const setOrder = ['SOR', 'SHD', 'TWI', 'JTL'];
                    return setOrder.filter(set => setGroups[set]).map(set => `
                        <div class="set-group">
                            <div class="set-header">${set}</div>
                            <div class="card-grid">
                                ${setGroups[set].map(card => 
                                    buildCardHTML(card.id, card.data, card.count)
                                ).join('')}
                            </div>
                        </div>`
                    ).join('');
            }
        }

        async function resortCards(sortType, clickedButton) {
            // Update active button state
            document.querySelectorAll('.sort-button').forEach(button => {
                button.classList.remove('active');
            });
            if (clickedButton) {
                clickedButton.classList.add('active');
            }

            // Store currently selected cards by their IDs
            const selectedCardIds = new Set(
                Array.from(document.querySelectorAll('.card.selected'))
                    .map(card => card.getAttribute('data-card-id'))
            );

            const mainContent = await displaySortedCards(sortType);
            
            // Find the deck-header (leaders & base section)
            const deckHeader = document.querySelector('.deck-header');
            if (deckHeader) {
                // Replace everything after the deck-header
                let next = deckHeader.nextElementSibling;
                while (next) {
                    const current = next;
                    next = current.nextElementSibling;
                    current.remove();
                }
                deckHeader.insertAdjacentHTML('afterend', mainContent);

                // Restore selected states
                document.querySelectorAll('.card').forEach(card => {
                    if (selectedCardIds.has(card.getAttribute('data-card-id'))) {
                        card.classList.add('selected');
                    }
                });
            }
        }

        function buildCardHTML(cardId, cardData = {}, count = 1) {
            const aspects = cardData.Aspects || [];
            const stats = [];
            if (cardData.Cost !== undefined) stats.push(['Cost', cardData.Cost]);
            if (cardData.Power !== undefined) stats.push(['Power', cardData.Power]);
            if (cardData.HP !== undefined) stats.push(['HP', cardData.HP]);

            const formattedId = cardId.replace('_', ' ');
            const isDoubleSided = cardData.DoubleSided === true;
            
            return `
            <div class="card" 
                onclick="this.classList.toggle('selected')" 
                data-card-id="${formattedId}">
                <div class="card-id">
                    <span>${formattedId}</span>
                    ${isDoubleSided ? '<button class="flip-button" onclick="event.stopPropagation(); this.closest(\'.card\').classList.toggle(\'flipped\')">Flip Card</button>' : ''}
                </div>
                <div class="card-name">${cardData.Name || cardId}${count > 1 ? ` (${count})` : ''}</div>
                ${aspects.length ? `
                    <div class="aspects">
                        ${aspects.map(aspect => `
                            <span class="aspect ${aspect}">${aspect}</span>
                        `).join('')}
                    </div>
                ` : ''}
                <div class="card-images">
                    <div class="card-images-inner">
                        <div class="card-front">
                            ${cardData.FrontArt ? 
                                `<img src="${cardData.FrontArt}" alt="${cardData.Name || cardId} (Front)">` : 
                                `<div class="card-placeholder">${cardId}</div>`}
                        </div>
                        ${isDoubleSided && cardData.BackArt ? `
                            <div class="card-back">
                                <img src="${cardData.BackArt}" alt="${cardData.Name || cardId} (Back)">
                            </div>
                        ` : ''}
                    </div>
                </div>
                <div class="card-content">
                    ${stats.length ? `
                        <div class="card-stats">
                            ${stats.map(([label, value]) => `
                                <span class="stat" data-type="${label}">${label}: <span class="stat-value">${value}</span></span>
                            `).join('')}
                        </div>
                    ` : ''}
                </div>
            </div>`;
        }

        // Add a helper function to find elements by text content
        Document.prototype.querySelector = (function(querySelector) {
            return function(selector) {
                if (selector.includes(':contains(')) {
                    const match = selector.match(/:contains\('([^']+)'\)/);
                    if (match) {
                        const text = match[1];
                        const baseSelector = selector.replace(/:contains\('[^']+'\)/, '');
                        const elements = this.querySelectorAll(baseSelector);
                        return Array.from(elements).find(el => el.textContent.trim() === text);
                    }
                }
                return querySelector.call(this, selector);
            };
        })(Document.prototype.querySelector);

        // Initialize recent decks UI
        updateRecentDecksUI();
    </script>
</body>
</html>