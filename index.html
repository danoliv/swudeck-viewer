<!DOCTYPE html>
<html>
<head>
    <title>SWU Deck Viewer</title>
    <link rel="stylesheet" href="styles.css">
    <script src="sets.js"></script>
    <style>
        /* Page-specific styles only */
    </style>
</head>
<body>
    <div class="navigation">
        <a href="index.html">Deck Viewer</a>
        <a href="compare.html">Deck Comparison</a>
    </div>
    
    <h1>SWU Deck Viewer</h1>
    <div>
        <input type="text" id="deckUrl" 
               placeholder="Paste SWUDB deck URL (e.g., https://swudb.com/deck/123...)">
        <button onclick="loadDeck()">Load Deck</button>
        <button onclick="clearSetCache()" style="background: #ff9800; margin-left: 10px;">Clear All Cache</button>
        <span id="loading" class="loading" style="display: none;">Loading...</span>
    </div>
    <div id="recentDecks" class="recent-decks"></div>
    <div id="error" class="error"></div>
    <div id="output"></div>
<script src="card-module.js"></script>
<script>
        // Use only AllOrigins as the CORS proxy
        const PROXY = 'https://api.allorigins.win/raw?url=';
        const TIMEOUT_MS = 10000; // 10 second timeout

        // Recent decks storage
        const MAX_RECENT_DECKS = 8;
        let recentDecks = JSON.parse(localStorage.getItem('recentDecks') || '[]');

        // Update recent decks UI
        function updateRecentDecksUI() {
            const recentDecksDiv = document.getElementById('recentDecks');
            if (recentDecks.length === 0) {
                recentDecksDiv.style.display = 'none';
                return;
            }

            let html = '<div class="recent-decks-title">Recent Decks:</div>';
            html += '<div class="quick-compare-section" style="margin-bottom: 15px; padding: 10px; background: #e8f4fd; border-radius: 4px;">';
            html += '<strong>Quick Compare:</strong> Select two decks to compare them instantly. ';
            html += '<button onclick="quickCompare()" style="background: #0066cc; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer;">Compare Selected</button>';
            html += '</div>';
            html += '<div class="recent-decks-list">';
            recentDecks.forEach((deck, index) => {
                const leaderImg = deck.leaderArt ? 
                    `<img src="${deck.leaderArt}" alt="Leader" onerror="this.style.display='none'">` : '';
                
                html += `<div class="recent-deck-container" style="position: relative;">
                    <button onclick="loadDeckFromUrl('${deck.url}')" class="recent-deck-btn">
                        <div class="aspect ${deck.baseAspect} recent-deck-base-bg"></div>
                        <div class="recent-deck-name"><span>${deck.name || 'Unnamed Deck'}</span></div>
                        ${leaderImg}
                    </button>
                    <input type="checkbox" onclick="toggleDeckSelection('${deck.url}', this)" class="deck-checkbox" style="position: absolute; top: 8px; left: 8px; z-index: 10; width: 16px; height: 16px; cursor: pointer;">
                </div>`;
            });
            html += '</div>';
            recentDecksDiv.innerHTML = html;
            recentDecksDiv.style.display = 'block';
        }

        // Add deck to recent list
        async function addToRecentDecks(url, deckData) {
            const now = new Date();
            const dateStr = now.toLocaleDateString();
            
            // Get leader art URL and base aspect
            console.log('Deck data:', deckData);
            const leaderArt = deckData.leader?.FrontArt || (deckData.leader ? `https://cdn.swu-db.com/images/cards/${deckData.leader.id.replace('_', '/')}.png` : null);
            
            // Fetch base card data to get correct aspect
            let baseAspect = 'Command'; // Default
            if (deckData.base?.id) {
                const baseCardData = await fetchCardData(deckData.base.id);
                if (baseCardData?.Aspects?.length > 0) {
                    baseAspect = baseCardData.Aspects[0];
                }
            }
            
            console.log('Leader art:', leaderArt);
            console.log('Base aspect:', baseAspect);
            
            // Remove if already exists
            recentDecks = recentDecks.filter(deck => deck.url !== url);
            
            // Add to front of array
            recentDecks.unshift({ 
                url, 
                name: deckData.metadata?.name || 'Unnamed Deck',
                leaderArt,
                baseAspect,
                date: dateStr 
            });
            
            // Keep only last 8 recent decks
            if (recentDecks.length > MAX_RECENT_DECKS) {
                recentDecks = recentDecks.slice(0, MAX_RECENT_DECKS);
            }
            
            // Save to localStorage
            localStorage.setItem('recentDecks', JSON.stringify(recentDecks));
            
            // Update UI
            updateRecentDecksUI();
        }

        // Load deck from URL
        async function loadDeckFromUrl(url) {
            document.getElementById('deckUrl').value = url;
            // Estrai il deck ID dall'URL e carica sempre dati freschi
            const deckId = url.split('/').pop();
            await loadDeckById(deckId, true); // true = bypass cache
        }


        // Track selected decks for quick compare
        let selectedDecks = [];

        // Toggle deck selection for quick compare
        function toggleDeckSelection(url, checkbox) {
            const container = checkbox.closest('.recent-deck-container');
            
            if (checkbox.checked) {
                if (selectedDecks.length < 2) {
                    selectedDecks.push(url);
                    container.classList.add('selected');
                } else {
                    // Already have 2 selected, uncheck this one
                    checkbox.checked = false;
                    alert('You can only select 2 decks for comparison. Uncheck another deck first.');
                }
            } else {
                selectedDecks = selectedDecks.filter(deck => deck !== url);
                container.classList.remove('selected');
            }
            
            // Update the compare button state
            updateCompareButton();
        }

        // Update the compare button based on selection
        function updateCompareButton() {
            const compareBtn = document.querySelector('button[onclick="quickCompare()"]');
            if (compareBtn) {
                if (selectedDecks.length === 2) {
                    compareBtn.textContent = 'Compare Selected (2)';
                    compareBtn.style.background = '#00a651';
                } else {
                    compareBtn.textContent = `Compare Selected (${selectedDecks.length}/2)`;
                    compareBtn.style.background = '#0066cc';
                }
            }
        }

        // Quick compare function
        function quickCompare() {
            if (selectedDecks.length !== 2) {
                alert('Please select exactly 2 decks to compare.');
                return;
            }
            
            const deck1Id = selectedDecks[0].split('/').pop();
            const deck2Id = selectedDecks[1].split('/').pop();
            
            // Open compare page with both decks
            window.open(`compare.html?deck1=${deck1Id}&deck2=${deck2Id}`, '_blank');
            
            // Clear selection
            selectedDecks = [];
            document.querySelectorAll('.deck-checkbox').forEach(cb => {
                cb.checked = false;
                cb.closest('.recent-deck-container').classList.remove('selected');
            });
            updateCompareButton();
        }

        // Utility function to retry failed fetch requests
        async function fetchWithRetry(url, retries = 3, bypassCache = false) {
            for (let i = 0; i < retries; i++) {
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), TIMEOUT_MS);
                    
                    // Aggiungi parametro per bypassare la cache se richiesto
                    const fetchUrl = bypassCache ? `${url}${url.includes('?') ? '&' : '?'}_t=${Date.now()}` : url;
                    
                    const response = await fetch(fetchUrl, { 
                        signal: controller.signal,
                        cache: bypassCache ? 'no-cache' : 'default'
                    });
                    clearTimeout(timeoutId);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const contentType = response.headers.get("content-type");
                    if (contentType && contentType.includes("application/json")) {
                        return await response.json();
                    } else {
                        throw new Error("Response was not JSON");
                    }
                } catch (error) {
                    if (i === retries - 1) throw error; // Last retry failed
                    console.warn(`Attempt ${i + 1} failed, retrying...`, error);
                    await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1))); // Exponential backoff
                }
            }
        }


        // Check for deck ID in URL when page loads
        window.addEventListener('load', function() {
            // Check for deck in query parameters
            const urlParams = new URLSearchParams(window.location.search);
            const deckId = urlParams.get('deck');
            
            if (deckId) {
                // Popola il campo input con l'URL completo
                document.getElementById('deckUrl').value = `https://swudb.com/deck/${deckId}`;
                loadDeckById(deckId);
            }
        });

        // Modify the loadDeck function
        async function loadDeck() {
            const urlInput = document.getElementById('deckUrl').value.trim();
            const output = document.getElementById('output');
            const errorDiv = document.getElementById('error');
            const loading = document.getElementById('loading');
            
            errorDiv.textContent = '';
            output.innerHTML = '';
            loading.style.display = 'inline';

            try {
                // Extract deck ID from URL
                const url = new URL(urlInput);
                const pathSegments = url.pathname.split('/').filter(Boolean);
                const deckId = pathSegments[pathSegments.length - 1];
                
                if (!deckId) {
                    throw new Error('Invalid SWUDB URL - Could not extract deck ID');
                }

                await loadDeckById(deckId);
                
                // Update URL without reloading the page
                window.history.pushState({}, '', `?deck=${deckId}`);

            } catch (err) {
                console.error('Error loading deck:', err);
                errorDiv.textContent = `Error: ${err.message}. Please verify the deck URL is correct and try again.`;
                loading.style.display = 'none';
            }
        }

        async function loadDeckById(deckId, bypassCache = false) {
            const errorDiv = document.getElementById('error');
            const output = document.getElementById('output');
            const loading = document.getElementById('loading');
            
            try {
                console.log('Loading deck:', deckId, bypassCache ? '(bypassing cache)' : '');
                
                // Use the CORS proxy for the API endpoint
                const deckData = await fetchWithRetry(`${PROXY}${encodeURIComponent(`https://swudb.com/api/getDeckJson/${deckId}`)}`, 3, bypassCache);
                
                if (!deckData) {
                    throw new Error('Failed to load deck data - Server returned empty response');
                }

                if (deckData.error) {
                    throw new Error(`API Error: ${deckData.error}`);
                }

                // Validate deck data structure
                if (!deckData.deck) {
                    throw new Error('Invalid deck data format received from server');
                }

                // Add to recent decks
                await addToRecentDecks(`https://swudb.com/deck/${deckId}`, deckData);
                
                // Process cards
                const grouped = await groupCards(deckData.deck);
                console.log('Grouped sets:', grouped);
                
                // Log sideboard info
                console.log('Sideboard data:', deckData.sideboard);
                if (deckData.sideboard) {
                    console.log('Sideboard length:', deckData.sideboard.length);
                    console.log('Sideboard cards:', deckData.sideboard);
                }
                
                await displayDeck(deckData, grouped);
                
                // Update URL without reloading the page
                window.history.pushState({}, '', `?deck=${deckId}`);
                
            } catch (err) {
                console.error('Error loading deck:', err);
                errorDiv.textContent = `Error: ${err.message}. Please verify the deck ID is correct and try again.`;
            } finally {
                loading.style.display = 'none';
            }
        }

        async function groupCards(cards) {
            if (!Array.isArray(cards)) {
                console.error('Invalid cards data:', cards);
                return {};
            }

            const sets = {};
            cards.forEach(card => {
                if (!card || !card.id) {
                    console.warn('Invalid card data:', card);
                    return;
                }

                const [set, num] = card.id.split('_');
                if (!set || !num) {
                    console.warn('Invalid card ID format:', card.id);
                    return;
                }

                if (!sets[set]) sets[set] = [];
                sets[set].push({
                    id: card.id,
                    number: parseInt(num, 10),
                    count: card.count || 1
                });
            });
            
            // Sort cards within each set
            Object.keys(sets).forEach(set => {
                sets[set].sort((a, b) => a.number - b.number);
            });

            // Create a new object with sets in the desired order
            const orderedSets = {};
            const setOrder = loadSets();
            setOrder.forEach(set => {
                if (sets[set]) {
                    orderedSets[set] = sets[set];
                }
            });
            // Aggiungi eventuali set non previsti in setOrder
            Object.keys(sets).forEach(set => {
                if (!orderedSets[set]) {
                    orderedSets[set] = sets[set];
                }
            });

            return orderedSets;
        }

        async function displayDeck(deckData, grouped) {
            const { metadata, leader, secondleader, base, sideboard } = deckData;
            const deckUrl = document.getElementById('deckUrl').value.trim();
            let html = `<h2><a href="${deckUrl}" target="_blank" style="color: inherit; text-decoration: none; border-bottom: 1px dotted #666;">${metadata?.name || 'Unnamed Deck'}</a></h2>`;

            // Add sorting controls
            html += `
            <div class="sort-controls">
                <span class="sort-label">Group by:</span>
                <button class="sort-button active" onclick="resortCards('set', this)">Set & Number</button>
                <button class="sort-button" onclick="resortCards('cost', this)">Cost</button>
                <button class="sort-button" onclick="resortCards('aspect', this)">Aspect</button>
                <button class="sort-button" onclick="resortCards('type', this)">Card Type</button>
                <button class="sort-button" onclick="resortCards('trait', this)">Traits</button>
            </div>`;
            
            // Display leaders and base in the same grid
            if (leader || secondleader || base) {
                html += '<div class="deck-header">';
                html += '<div class="section-title">Leaders & Base</div>';
                if (leader) {
                    const leaderCard = await fetchCardData(leader.id);
                    html += buildCardHTML(leader.id, leaderCard);
                }
                if (secondleader) {
                    const secondLeaderCard = await fetchCardData(secondleader.id);
                    html += buildCardHTML(secondleader.id, secondLeaderCard);
                }
                if (base) {
                    const baseCard = await fetchCardData(base.id);
                    html += buildCardHTML(base.id, baseCard);
                }
                html += '</div>';
            }

            // Store the grouped cards for resorting
            window.currentDeckCards = [];
            const cardMap = new Map(); // Per tenere traccia delle carte uniche
            
            // Process main deck cards
            for (const set of Object.keys(grouped)) {
                for (const card of grouped[set]) {
                    const cardData = await fetchCardData(card.id);
                    cardMap.set(card.id, {
                        id: card.id,
                        count: card.count,
                        sideboardCount: 0,
                        data: cardData
                    });
                }
            }

            // Add sideboard cards to the same map
            if (Array.isArray(deckData.sideboard) && deckData.sideboard.length > 0) {
                const groupedSide = await groupCards(deckData.sideboard);
                for (const set of Object.keys(groupedSide)) {
                    for (const card of groupedSide[set]) {
                        if (cardMap.has(card.id)) {
                            // Carta già presente nel main deck, aggiungi solo il conteggio sideboard
                            cardMap.get(card.id).sideboardCount = card.count;
                        } else {
                            // Carta solo nel sideboard
                            const cardData = await fetchCardData(card.id);
                            cardMap.set(card.id, {
                                id: card.id,
                                count: 0,
                                sideboardCount: card.count,
                                data: cardData
                            });
                        }
                    }
                }
            }
            
            // Convert map to array
            window.currentDeckCards = Array.from(cardMap.values());

            // Initial sort by set
            html += await displaySortedCards('set');

            output.innerHTML = html;
        }

        async function displaySortedCards(sortType) {
            if (!window.currentDeckCards) return '';

            let html = '';
            switch (sortType) {
                case 'cost':
                    // Group by cost
                    const costGroups = {};
                    window.currentDeckCards.forEach(card => {
                        const cost = card.data.Cost !== undefined ? card.data.Cost : 'X';
                        if (!costGroups[cost]) costGroups[cost] = [];
                        costGroups[cost].push(card);
                    });
                    
                    Object.keys(costGroups).sort((a, b) => {
                        if (a === 'X') return 1;
                        if (b === 'X') return -1;
                        return parseInt(a) - parseInt(b);
                    }).forEach(cost => {
                        html += `
                            <div class="set-group">
                                <div class="set-header">Cost: ${cost}</div>
                                <div class="card-grid">
                                    ${costGroups[cost].map(card => 
                                        buildCardHTML(card.id, card.data, card.count, card.sideboardCount)
                                    ).join('')}
                                </div>
                            </div>`;
                    });
                    return html;

                case 'aspect':
                    // Group by aspect
                    const aspectGroups = {};
                    window.currentDeckCards.forEach(card => {
                        const aspects = card.data.Aspects || ['None'];
                        aspects.forEach(aspect => {
                            if (!aspectGroups[aspect]) aspectGroups[aspect] = [];
                            aspectGroups[aspect].push(card);
                        });
                    });
                    
                    return Object.keys(aspectGroups).sort().map(aspect => `
                        <div class="set-group">
                            <div class="set-header">${aspect}</div>
                            <div class="card-grid">
                                ${aspectGroups[aspect].map(card => 
                                    buildCardHTML(card.id, card.data, card.count, card.sideboardCount)
                                ).join('')}
                            </div>
                        </div>`
                    ).join('');

                case 'type':
                    // Group by card type with space/ground separation
                    const typeGroups = {};
                    window.currentDeckCards.forEach(card => {
                        let type = card.data.Type || 'Unknown';
                        console.log('Card:', card.data.Name, 'Type:', type, 'Arenas:', card.data.Arenas);
                        
                        // Split units into Space and Ground based on Arenas field
                        if (type === 'Unit') {
                            if (card.data.Arenas && card.data.Arenas.includes('Space')) {
                                type = 'Space Unit';
                            } else {
                                type = 'Ground Unit';
                            }
                        }
                        if (!typeGroups[type]) typeGroups[type] = [];
                        typeGroups[type].push(card);
                    });
                    
                    console.log('Final groups:', typeGroups);
                    
                    // Define type order with Ground Units first
                    const typeOrder = ['Ground Unit', 'Space Unit', 'Event', 'Upgrade', 'Unknown'];
                    return typeOrder
                        .filter(type => typeGroups[type] && typeGroups[type].length > 0)
                        .map(type => `
                            <div class="set-group">
                                <div class="set-header">${type} (${typeGroups[type].length})</div>
                                <div class="card-grid">
                                    ${typeGroups[type].map(card => 
                                        buildCardHTML(card.id, card.data, card.count, card.sideboardCount)
                                    ).join('')}
                                </div>
                            </div>`
                        ).join('');

                case 'trait':
                    // Group by traits
                    const traitGroups = {};
                    window.currentDeckCards.forEach(card => {
                        console.log('Processing card:', card.data.Name);
                        console.log('Raw Traits:', card.data.Traits);
                        
                        // Handle traits that are already an array or convert string to array
                        const traits = Array.isArray(card.data.Traits) 
                            ? card.data.Traits 
                            : (card.data.Traits || '').split(',').map(t => t.trim());
                        
                        // Filter out empty traits
                        const validTraits = traits.filter(t => t);
                        
                        console.log('Processed Traits:', validTraits);
                        
                        if (validTraits.length === 0) {
                            // Handle cards with no traits
                            if (!traitGroups['No Traits']) traitGroups['No Traits'] = [];
                            traitGroups['No Traits'].push(card);
                            console.log('Added to No Traits group');
                        } else {
                            // Add card to each of its trait groups
                            validTraits.forEach(trait => {
                                if (!traitGroups[trait]) {
                                    traitGroups[trait] = [];
                                    console.log('Created new trait group:', trait);
                                }
                                traitGroups[trait].push(card);
                                console.log('Added to trait group:', trait);
                            });
                        }
                    });
                    
                    console.log('Final trait groups:', traitGroups);
                    
                    // Sort trait groups alphabetically, but put "No Traits" at the end
                    const sortedTraits = Object.keys(traitGroups)
                        .sort((a, b) => {
                            if (a === 'No Traits') return 1;
                            if (b === 'No Traits') return -1;
                            return a.localeCompare(b);
                        });

                    console.log('Sorted traits:', sortedTraits);

                    return sortedTraits
                        .map(trait => `
                            <div class="set-group">
                                <div class="set-header">${trait} (${traitGroups[trait].length})</div>
                                <div class="card-grid">
                                    ${traitGroups[trait].map(card => 
                                        buildCardHTML(card.id, card.data, card.count, card.sideboardCount)
                                    ).join('')}
                                </div>
                            </div>`
                        ).join('');

                default: // 'set'
                    // Group by set
                    const setGroups = {};
                    window.currentDeckCards.forEach(card => {
                        const [set] = card.id.split('_');
                        if (!setGroups[set]) setGroups[set] = [];
                        setGroups[set].push(card);
                    });
                    
                    // Log per debug
                    console.log('Set groups for display:', setGroups);
                    
                    // Usa lo stesso setOrder di groupCards
                    const setOrder = loadSets();
                    setOrder.forEach(set => {
                        if (setGroups[set]) {
                            html += `
                                <div class="set-group">
                                    <div class="set-header">${set}</div>
                                    <div class="card-grid">
                                        ${setGroups[set].map(card => 
                                            buildCardHTML(card.id, card.data, card.count, card.sideboardCount)
                                        ).join('')}
                                    </div>
                                </div>`;
                        }
                    });
                    // Aggiungi eventuali set non previsti in setOrder
                    Object.keys(setGroups).forEach(set => {
                        if (!setOrder.includes(set)) {
                            html += `
                                <div class="set-group">
                                    <div class="set-header">${set}</div>
                                    <div class="card-grid">
                                        ${setGroups[set].map(card => 
                                            buildCardHTML(card.id, card.data, card.count, card.sideboardCount)
                                        ).join('')}
                                    </div>
                                </div>`;
                        }
                    });
                    return html;
            }
        }

        async function resortCards(sortType, clickedButton) {
            // Update active button state
            document.querySelectorAll('.sort-button').forEach(button => {
                button.classList.remove('active');
            });
            if (clickedButton) {
                clickedButton.classList.add('active');
            }

            // Store currently selected cards by their IDs
            const selectedCardIds = new Set(
                Array.from(document.querySelectorAll('.card.selected'))
                    .map(card => card.getAttribute('data-card-id'))
            );

            const mainContent = await displaySortedCards(sortType);
            
            // Find the deck-header (leaders & base section)
            const deckHeader = document.querySelector('.deck-header');
            if (deckHeader) {
                // Replace everything after the deck-header
                let next = deckHeader.nextElementSibling;
                while (next) {
                    const current = next;
                    next = current.nextElementSibling;
                    current.remove();
                }
                deckHeader.insertAdjacentHTML('afterend', mainContent);

                // Restore selected states
                document.querySelectorAll('.card').forEach(card => {
                    if (selectedCardIds.has(card.getAttribute('data-card-id'))) {
                        card.classList.add('selected');
                    }
                });
            }
        }


        // Add a helper function to find elements by text content
        Document.prototype.querySelector = (function(querySelector) {
            return function(selector) {
                if (selector.includes(':contains(')) {
                    const match = selector.match(/:contains\('([^']+)'\)/);
                    if (match) {
                        const text = match[1];
                        const baseSelector = selector.replace(/:contains\('[^']+'\)/, '');
                        const elements = this.querySelectorAll(baseSelector);
                        return Array.from(elements).find(el => el.textContent.trim() === text);
                    }
                }
                return querySelector.call(this, selector);
            };
        })(Document.prototype.querySelector);

        // Initialize recent decks UI
        updateRecentDecksUI();

        function clearSetCache() {
            // Clear card cache using shared module
            clearCardCache();
            
            // Clear recent decks from localStorage
            localStorage.removeItem('recentDecks');
            recentDecks = [];
            
            // Clear current deck global variable
            if (window.currentDeckCards) {
                delete window.currentDeckCards;
            }
            
            // Clear UI
            document.getElementById('recentDecks').style.display = 'none';
            document.getElementById('output').innerHTML = '';
            document.getElementById('error').textContent = '';
            document.getElementById('deckUrl').value = '';
            
            // Clear browser cache for images
            if ('caches' in window) {
                caches.keys().then(names => {
                    names.forEach(name => {
                        caches.delete(name);
                    });
                });
            }
            
            // Reload page to ensure everything is completely reset
            window.location.href = window.location.pathname;
        }
    </script>
</body>
</html>